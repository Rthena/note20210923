### 1、Redis是什么

Redis 是一个开源的，内存数据结构存储，可用于数据库，缓存，消息发送。Redis提供的数据结构有 strings，hashs， lists，sets， sorted sets，并且还提供了这些数据结构的范围查询，hyperloglogs, geospatial indexes, and stream。Redis还内建了备份，lua脚本，LRU淘汰算法，事务，和不同级别的磁盘持久化。Redis 同时还提供了高可用的 Sentinel 哨兵模式和Redis集群自动分区

### 2、Redis为什么会这么快

Redis 需然是单线程模型，但是Redis 完成是基于内存操作，CPU不是Redis的瓶颈，Redis的最可能瓶颈是内存大小或者网络IO。

Redis为什么这么快；

第一：Redis完成基于内存，纯内存操作，速度非常快。
第二：数据结构简单，对数据操作也简单。
第三：采用单线程，避免不必要的上下稳切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁的操作，没有死锁问题导致的性能消耗
第四：使用IO多路复用模型，非阻塞IO

### 3、Redis和Memcached的区别
1、存储方式上：memcache把数据全部保存在内存中，断电会丢失。redis 有持久化策略，使用过程中会有部分数据落盘。
2、数据支持类型：memcache仅支持简单的 key-value的数据类型。redis支持5种数据类型。
3、底层模型不同：
4、value的大小：redis可以达到1GB，而memcache只有1MB

### 4、[淘汰策略](https://redis.io/topics/lru-cache)
当达到设置的最大内存使用值 maxmemory时采用的淘汰策略
**noevition**：不淘汰策略，当内存达到了限定值时，客户端试图执行那些会导致内存使用更多的命令时，会之间报错（大多数是写操作命令，del命令和少数例外）
**allkeys-lru**：从所以keys 中淘汰最近最少使用的（LRU）keys
**volatile-lru**：从已设置了过期时间的keys 优先淘汰最近最少使用的数据。
**allkeys-random**：从所有的keys 中随机淘汰
**volatile-random**：从已设置过期时间的keys 中随机淘汰
**volatile-ttl**：从已设置过期时间的keys 中优先对剩余时间短的(ttl)的数据淘汰

### 5、[持久化机制](https://redis.io/topics/persistence)
- **RDB**：在指定的时间间隔，把内存中的数据保存到一个dump文件中。
- **AOF**：把所有的对 redis服务器进行修改的命令日志 append到文件里。当redis服务器启动时会加载该日志文件重新把数据构建到内存中。这些命令日志是按照 redis的协议进行格式化的。
- **NO persistentce**：如果这些数据只在服务器运行时才存在，那么这些数据可以不用保存。
  **RDB+AOF**：RDB，AOF可以同时使用。需要注意的是当Redis服务器重新启动的时候，默认是使用AOF 还原数据的，因为这样可以保证数据的完整性

- **提示** 最重要的是你要理解它们之间有何区别，然后在权衡一下应该使用何种方式比较合适

**RDB 优点**

- RDB是一个非常紧凑的单文件。RDB文件非常合适于备份，对于一个 redis实例你可以设置最近24小时内，每小时保存一次快照，也可以在30天内，每天保存一次快照。如果有灾难发生的时候可以根据不同的版本恢复数据。
- RDB非常有利于灾难恢复，单个压缩文件可传输到数据中心，也可以放到远程的服务器
- RDB 可以最低化Reids的性能。父线程fork 子线程，子线程来持久化数据。
- 相比较于AOF 庞大的数据集，RDB启动得更快
- 备份方面，RDB支持 部分同步

**RDB 缺点**

- Redis服务故障时可能会丢失少量数据。每5分钟或者更长的时间创建一个快照，这个时候如果redis 没有正常退出，就会可能丢失最近几分钟内的数据。
- RDB经常需要fork()，以便子进程把内存数据保存到磁盘上，如果数据集很大，fork()会很耗时，可能会导致Redis停止对客户端提供服务几毫秒甚至1秒。如果dataset非常大，那么对CPU是不友好的。AOF也有fork()操作，但是你可以调整多久重写日志的频率，而不需要在持久性上做任何权衡



**AOF 优点**

- 使用 AOF Redis会更持久。你可以有不同的 fsync 策略：no fsync at all, fsync every second, fsync at every query。默认的每秒钟同步策略，依然有很好的性能。
- AOF 日志是一个只能追加的日志，因此在断电之后不会出现寻道或者损坏问题。因此日志由于某种原因（磁盘已满或者其他原因）以半写命令结束，redis-check-aof 工具也能轻松修复。
- 当 AOF 变大时，Redis 能够在后台自动重写 AOF。 重写是完全安全的，因为当 Redis 继续追加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换这两个文件并开始追加到 新的那一个。
- AOF 以易于理解和解析的格式包含所有操作的日志。 您甚至可以轻松导出 AOF 文件。 例如，即使您不小心使用 FLUSHALL 命令刷新了所有内容，只要在此期间没有重写日志，您仍然可以通过停止服务器、删除最新命令并重新启动 Redis 来保存您的数据集 再次。

**AOF 缺点**

- AOF 文件通常比相同数据集的等效 RDB 文件大。
- AOF 比RDB慢取决于采用那种 fsync 策略，通常来说 fsync 设置成每秒，性能依然是很高的，并且 即使禁用 fsync ，在高负载的情况下AOF的也应该比RDB快。但是即使在写入负载巨大的情况下，RDB 仍然能够提供更多关于最大延迟的保证。
- AOF存在Bug，我们从未收到过用户关于在现实世界中检测到的 AOF 损坏的单一报告。



**该如何选择**

- 如果您非常关心您的数据，但在发生灾难时仍然可以忍受几分钟的数据丢失，您可以简单地单独使用 RDB。
- 数据库备份和灾难恢复，RDB快照非常便于数据库备份，并且RDB恢复数据集的速度比AOF 快。

**这两种持久化方式的更多细节**

**Snapshotting**

​	默认情况下，Redis会将数据集快照保存在磁盘上一个名为 dump.rdb的二进制文件中。你可以设置 Redis在 N 秒内最少有 M 次修改保存一次数据集，或者您可以手动调用 SAVE 或 BGSAVE 命令

例如，如下配置，60秒内最少有1000个key 被修改，Redis 将自动把数据集保存到磁盘

```
save 60 1000
```

工作原理

- Redis forks，子进程和父进程。
- 子进程把数据集写入到一个临时文件中。
- 当子进程完成写临时文件后，它会替换旧的 RDB文件

这样的好处是copy-on-write



**Append-only file**

快照方式 *Snapshotting*，并不是那么的可靠，如果你运行Redis的计算机停止工作了，你的电源线坏了，或者是你不小心执行了 kill -9 命令了，这就意味着最近写入到 Redis的数据丢失了。对于一些应用来说这并不是什么大问题，但是对于需要完全可靠的场景来说，Redis不是可行的选择。

对于完全可靠场景 *Append-only file* 模式非常合适。

您可以在配置文件中打开 AOF

```
appendonly yes
```

*Append only file* 是怎样持久化的？

- appendfsync always:  #每次有数据修改发生时都会写入AOF文件。
- appendfsync everysec: #每秒钟保存一次，足够快，即使是发生灾难，也只会丢失 1秒钟的数据
- appendfsync no: #不进行同步，只是把你的数据交给操作系统，速度相当的快，却并不安全。

默认策略是 fsync everysec，速度快并且相当的安全 ，always 策略在实践中很慢，但它支持组提交 group commit，所以如果有多个并行写入 Redis 可以尝试执行单个 fsync 操作。



如果我们的 AOF 被截断了，应该怎样做


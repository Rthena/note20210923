## Redis 真的只有单线程吗？
Redis 是单线程，主要是指 **Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储的主要流程**。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

## Redis 为什么用单线程？

1、多线程的开销。多线程编程模式的共享资源的并发访问控制问题。

## 单线程 Redis 为什么那么快？
一方面，Redis 的大部分操作在内存上完成，高效的数据结构，例如哈希表和跳表
另一方面，Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐量。

1、基本 IO 模型与阻塞点

![image-20211026151713579](/Users/Rthena/Desktop/redis极客时间/03丨高性能IO模型：为什么单线程Redis能那么快？/Redis基本IO模型.png)

在这里的网络 IO 操作中，有潜在的阻塞点，分别是 **accept()**和 **recv()**。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里。类似的当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()

2、非阻塞模式

![image-20211026152350614](/Users/Rthena/Desktop/redis极客时间/03丨高性能IO模型：为什么单线程Redis能那么快？/非阻塞模式.png)

当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。虽然 Redis 线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。

到此，Linux 中的 IO 多路复用机制就要登场了！

3、基于多路复用的高性能 I/O 模型
**select/epoll机制**，简单的说，在 Redis 只运行单线程的情况下，**该机制允许内核中，同时存在多个监听套接字和已经连接套接字**。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理。

![image-20211026153305358](/Users/Rthena/Desktop/redis极客时间/03丨高性能IO模型：为什么单线程Redis能那么快？/基于多路复用的Redis高性能IO模型.png)
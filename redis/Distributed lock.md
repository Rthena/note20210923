#  [Distributed locks with Redis](https://redis.io/topics/distlock)

**安全和活跃性保证**

我们将要仅使用 3个属性对我们的设计进行建模，从我们的角度来看，这是有效使用分布式锁所需的最低保证。

1、安全属性：互斥。在任何时候，只有一个客户端持有锁。

2、活跃属性 A：无死锁。最终总是有可能获得锁，即使锁定资源客户端崩溃或被分区。

3、活跃属性 B：容错。只要大多数 Redis 节点都已启动，客户端就可以获取和释放锁。



**为什么基于故障转移的实现是不够的**

为了了解我们想要改进的地方，让我们分析一下大多数基于 Redis 的分布式锁库的当前状态。

使用 Redis 锁定资源的最简单方式是在实例里创建一个 key。key 通常是带有存活时间的，使用 Redis 的 expires 特性，以便最终将其释放（属性2）。当客户端需要释放资源时，它会删除这个 key。                                                                                              表面上看，很有效，但有一个问题：这是一个单点故障架构，如果 Redis 主机宕机怎么办？。好吧， 让我们来添加一个副本，当主机不可用的时候。

